syntax = "proto3";
package delta.kernel;

option java_package = "kernel.proto";
option java_outer_classname = "PlanProtos";

import "schema.proto";

// =============================================================================
// SIMPLIFIED PLAN NODES (9 types)
// =============================================================================

// -----------------------------------------------------------------------------
// Leaf Nodes (no children)
// -----------------------------------------------------------------------------

// Read files from storage
message ScanNode {
  enum FileType {
    FILE_TYPE_UNSPECIFIED = 0;
    PARQUET = 1;
    JSON = 2;
  }
  FileType file_type = 1;
  repeated string files = 2;
  Schema schema = 3;
}

// List files from storage path
message FileListingNode {
  string path = 1;  // Directory URL or file path to start after
}

// -----------------------------------------------------------------------------
// Unary Node Data (attached to child in tree structure)
// -----------------------------------------------------------------------------

// Filter using kernel-defined function (KDF) (e.g., AddRemoveDedup)
// KDFs contain Delta-specific logic that engines must use via kernel FFI.
// Returns per-row selection vector (BooleanArray).
message FilterByKDF {
  uint64 state_ptr = 1;  // Opaque handle to typed Rust state
}

// Consume using kernel-defined function (KDF) (e.g., LogSegmentBuilder)
// Unlike FilterByKDF which returns per-row selection, ConsumeByKDF returns
// a single boolean for the entire batch: true = Continue, false = Break.
// Used for operations that accumulate state across batches.
message ConsumeByKDF {
  uint64 state_ptr = 1;  // Opaque handle to typed Rust state
}

// Query parquet file schema (footer read only)
// This is a leaf node (no children)
message SchemaQueryNode {
  string file_path = 1;
  uint64 state_ptr = 2;  // Opaque handle to typed Rust state
}

// Filter using predicate expression
message FilterByExpressionNode {
  Expression predicate = 1;
}

// Project/transform columns
message SelectNode {
  repeated Expression columns = 1;
  Schema output_schema = 2;
}

// Parse JSON column into structured data
message ParseJsonNode {
  string json_column = 1;
  Schema target_schema = 2;
  string output_column = 3;
}

// Extract first non-null value for columns
message FirstNonNullNode {
  repeated string columns = 1;
}

// -----------------------------------------------------------------------------
// Sink Nodes (terminal nodes that consume data)
// -----------------------------------------------------------------------------

// Sink type determines what happens to data flowing into the sink
enum SinkType {
  DROP = 0;     // Discard all incoming data (consume without output)
  RESULTS = 1;  // Stream results back to the user
}

// Terminal node that consumes data flow
// All complete plans must end with a sink
message SinkNode {
  SinkType sink_type = 1;
}

// =============================================================================
// DECLARATIVE PLAN NODE (Tree Structure)
// =============================================================================

// Recursive tree structure for runtime interpretation
message DeclarativePlanNode {
  oneof node {
    // Leaf nodes (no children)
    ScanNode scan = 1;
    FileListingNode file_listing = 2;
    SchemaQueryNode schema_query = 3;

    // Unary nodes (one child)
    FilterByKDFPlan filter_by_kdf = 10;
    ConsumeByKDFPlan consume_by_kdf = 11;
    FilterByExpressionPlan filter_by_expression = 12;
    SelectPlan select = 13;
    ParseJsonPlan parse_json = 14;
    FirstNonNullPlan first_non_null = 15;

    // Sink nodes (terminal)
    SinkPlan sink = 16;

    // N-ary nodes (multiple children)
    UnionPlan union = 17;
  }
}

// -----------------------------------------------------------------------------
// Unary Plan Wrappers (child + node data)
// -----------------------------------------------------------------------------

message FilterByKDFPlan {
  DeclarativePlanNode child = 1;
  FilterByKDF node = 2;
}

message ConsumeByKDFPlan {
  DeclarativePlanNode child = 1;
  ConsumeByKDF node = 2;
}

message FilterByExpressionPlan {
  DeclarativePlanNode child = 1;
  FilterByExpressionNode node = 2;
}

message SelectPlan {
  DeclarativePlanNode child = 1;
  SelectNode node = 2;
}

message ParseJsonPlan {
  DeclarativePlanNode child = 1;
  ParseJsonNode node = 2;
}

message FirstNonNullPlan {
  DeclarativePlanNode child = 1;
  FirstNonNullNode node = 2;
}

message SinkPlan {
  DeclarativePlanNode child = 1;
  SinkNode node = 2;
}

// -----------------------------------------------------------------------------
// N-ary Plan Wrappers (multiple children)
// -----------------------------------------------------------------------------

// Union multiple child streams (concatenation)
message UnionPlan {
  repeated DeclarativePlanNode children = 1;
}

